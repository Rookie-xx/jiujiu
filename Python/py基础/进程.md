[toc]

## 进程理论基础

### **定义**：程序在计算机中的一次运行

> + 程序是一个可执行的文件，是静态的占有磁盘
> + 进程是一个动态的过程描述，占有计算机运行程序，有一定的生命周期

### **系统中如何产生一个进程**

1. 用户空间通过调用程序接口或者命令发起请求
2. 操作系统接收用户请求，开始创建进程
3. 操作系统调配计算机资源，确定进程状态
4. 操作系统将创建的进程提供给用户使用

### **进程基本概念**

+ cpu时间片：如果一个进程占有CPU内核则称这个进程在cpu时间片上

+ PCB(进程控制块)：在内存中开辟的一块空间，用于存放进程的基本信息，也用于系统查找识别进程

+ 进程ID(PID):系统为每个进程分配一个大于0的证书，作为进程ID，每个进程ID不重复

  > Linux查看进程ID：ps -aux

+ 父子进程：系统中每一个进程(除了系统初始化进程)都有唯一的父进程，可以有0个或多个子进程。

> 查看进程树：pstree

+ 进程状态

  + 三态

    就绪态：进程具备执行条件，等待分配cpu资源

    运行态：进程占有cpu时间片正在运行

    等待态：进程暂时停止运行，让出cpu

+ 状态查看命令：ps -aux --> STAT列

  > S  等待态
  >
  > R  执行态
  >
  > D  等待态
  >
  > T  等待态
  >
  > Z  僵尸

  > <  有较高优先级
  >
  > N  优化级较低
  >
  > \+   前台进程
  >
  > s   会话组组长
  >
  > l   有多线程

+ 进程的运行特征

  1. 进程可以使用计算多核资源
  2. 进程是计算机分配资源的最小单位
  3. 进程之间的运行互不影响，各自独立
  4. 每个进程拥有独立的空间，各自使用自己空间资源



> pid = os.fork()
>
> 功能：创建新的进程
>
> 返回值：如果创建进程失败返回一个负数，如果成功则在原有进程中返回新进程的PID，在新进程中返回0

> :star:注意
>
> > + 子进程会复制父进程全部内存空间，从fork下一句开始执行
> > + 父子进程各自独立运行，运行顺序不一定
> > + 利用父子进程fork返回值的区别，配合if结构让父子进程执行不同的内容几乎是固定搭配
> > + 父子进程各自特有特征比如PID PCB 命令集等
> > + 父进程fork之前开辟的空间子进程同样拥有，父子进程对各自空间的操作不会相互影响

```python
import os

#创建子进程
pid = os.fork()

if pid < 0:
    print('Create process faild')
#子进程执行部分    
elif pid == 0:
    print('The new process')
#父进程执行部分    
else:
    print('The old process')
#父子进程都会执行
print('Fork test over')
    
```

![](\图片\进程.png)

> :star:**子进程是从fork的下一句开始执行（赋值语句）!!!!!!!!**



![每个进程拥有独立空间](\图片\进程02.png)

```python
import os

print("============")
a = 1

pid = os.fork()
   
if pid == 0:
    print('The new process')
    pint('a = ',a) # 从父进程继承空间a
    a = 1000 # 修改自己的a
else:
    sleep(1)
    print('The old process')
	print('a:',a)

print('ALL a->',a) # 父子进程都执行

#============
#The new process
#a = 1
#ALL a-> 1000
#The old process
#a: 1
#ALL a-> 1
```

> :star:***子进程是从fork的下一句开始执行（赋值语句）!!!!!!!!!!!***

### **进程相关函数**

> os.getpid()
>
> 功能：获取一个进程的PID值
>
> 返回值：返回当前进程的PID

> os.getppid()
>
> 功能：获取父进程PID
>
> 返回值：返回父进程PID

> os._exit(status)
>
> 功能：结束一个进程
>
> 参数：进程的终止状态

> sys.exit([status])
>
> 功能：退出进程
>
> 参数：整数 表示退出状态
>
> 字符串：表示退出会打印字符串

### **孤儿和僵尸**

​		1.孤儿进程：父进程先于子进程退出，此时子进程成为孤儿进程。

> 特点：孤儿进程会被系统进程收养，此时系统进程就会成为孤儿进程新的父进程，孤儿进程退出该进程会自动处理

​		2.僵尸进程：子进程先于父进程退出，父进程又没有处理子进程的退出状态，			此时子进程就会成为僵尸进程。

> 特点：僵尸进程虽然结束，但是会存留部分PCB再内存中，大量的僵尸进程会浪费系统的内存资源

:star:<font color='red'>孤儿进程不会变成僵尸进程！！！</font>		

​		3.如何避免僵尸进程产生

+ 使用wait函数处理子进程退出

```python
"""
pid,status = os.wait()
功能：在父进程中阻塞等待处理子进程退出
返回值： pid  退出的子进程的PID
		status  子进程退出状态
"""


```

+ 创建二级子进程处理僵尸
  1. 父进程创建子进程，等待回收子进程
  2. 子进程创建二级子进程然后退出
  3. 二级子进程称为孤儿，和原来父进程一同执行事件

+ 通过信号处理子进程退出

> 原理子进程退出时会发送信号给父进程，如果父进程忽略子进程信号，则系统会自动处理子进程退出

> 方法：使用signal模块在父进程创建子进程前写如下语句：

```python
import signal
signal.signal(signal.SIGCHLD,singal.SIG_IGN)
```

> 特点：非阻塞，不会影响父进程运行，可以处理所有子进程退出