## 迭代

+ 概念：每一次对过程的重复称为一次迭代，而每一次得到的结果会作为下一次迭代的初始值 

+ **可迭代对象**

  ```python
  #可迭代对象  --容器
  list01 = [43,3,4,5,567]
  #迭代过程
  for item in list01:
  	print(item)
  #迭代原理
  
  #		可以被for的条件是什么？
  #		答：能被for的对象必须具备__iter__方法	
  #		答：可迭代对象
      
  #		for循环的原理是什么？
  #		1.获取迭代器
  #		2.循环获取下一个元素
  #		3.遇到异常停止迭代
  
  #1.获取迭代器
  iterator = list01.__iter__()
  #2.循环获取下一个元素
  while True:
  	try:
  		item = iterator.__next__()
  		print(item)
  		#3.遇到异常停止迭代
  		except StopIteration:
  			break#退出循环
  	
  
  ```

+ 迭代器

  ```python
  class Skill:
      pass
  
  class SkillIterator:
      """
          技能迭代器
      """
      def __init__(self,skilks):
          self.__skilks = skilks
          self.__index = 0
  
      def __next__(self):
          #如果没有错误则抛出异常
          if self.__index > len(self.__skilks) -1:
              raise StopIteration
  
          #返回下一个数据
          temp = self.__skilks[self.__index]
          self.__index += 1
          return  temp
  
  
  class SKillManager:
      """
          技能管理器  可迭代对象
      """
      def __init__(self):
          self.__skilks = []
  
      def add_skill(self,skill):
          self.__skilks.append(skill)
  
      def __iter__(self):
          #创建一个迭代器对象,并传递需要迭代的数据
          return SkillIterator(self.__skilks)
  
  manager = SKillManager()
  manager.add_skill(Skill())
  manager.add_skill(Skill())
  manager.add_skill(Skill())
  
  # for item in manager:
  #     print(item)
  
  iterator = manager.__iter__()
  
  while True:
      try:
          key = iterator.__next__()
          print(key)
      except StopIteration:
          break
  ```


## 生成器 

### **内置生成器**

#### 枚举函数enumerate

1. 语法：

   1. for 变量 in enumerate(可迭代对象)

      ​	语句

   2. for 索引,元素  in enumerate(可迭代对象)

      ​     语句

2. 作用：遍历迭代对象时，可以将索引与元素组合为一个元组

```python
list01 = [3,4,55,6,7]
for item in enumerate(list01):
    #(索引，元素)
    print(item)
    
#练习：定义生成器函数my_enumerate，实现将索引与元素组合为一个元组
def my_enumerate(iterable_target):
    idnex = 0
    for item in iterable_target:
        yield inedx,item
        index += 1
     
    #for index in range(len(iterable_target)):
    #    yield index,iterable_target[index]
```



#### ***zip***

1. 语法：
   1. for item in zip(可迭代对象1,可迭代对象2…)
2. 作用：将多个可迭代对象中对应的元素组合成一个元组

```python
#练习：定义生成器函数my_zip，实现下列现象
#将多个列表的每个元素合成一个元组
list02 = ['孙悟空','猪八戒','亚索']
list03 = [101,102,103]

# for item in zip(list02,list03):
#     print(item)


def my_zip(list_01,list_02):
    for i in range(len(list_01)):
        yield (list_01[i],list_02[i])

def my_zip2(*args):
	#根据星号元组形参args第一个参数的长度生成索引len(args[0])
    for i in range(len(args[0])):
        list_result = []
        for item in args:
            list_result.append(item[i])
        yield  tuple(list_result)     #item[i]   
my_zip = my_zip2(list02,list03)
for item in my_zip:
    print(item)   
```

### **生成器表达式**

1. 定义：用推导式创建生成器对象

```python
list01 = [5,'agg',True,30,False,30.3]
#生成器函数
def find01():
	for item in list01:
        if type(item) == int:
            yield item
re = find01()
for item in re:
    print(item)
    
# 生成器表达式
# 此时没有计算，更没有结果
re = (item for item in list01 if type(item) == int)
# 一次循环，一次计算，一个结果
for item in re:
    print(item)  

# 列表推导式
# 此时已经完成所有计算，得到所有结果
re = [item for item in list01 if type(item) == int]
#只是获取所有结果
for item in re:
    print(item)  
```

```python
class SkillData:
    def __init__(self,id,name,atk_ratio,duration):
        self.id = id
        self.name = name
        self.atk_ratio = atk_ratio
        self.duration = duration

    def __str__(self):
        return "技能:%d,%s,%d,%d"%(self.id,self.name,self.atk_ratio,self.duration)

list_skill = [
    SkillData(101,'乾坤大挪移',5,10),
    SkillData(101,'降龙十八掌',8,5),
    SkillData(101,'葵花宝典',10,2)
]
# 练习1：获取攻击比例大于6的所有技能
# 要求:使用生成器函数/生成器表达式完成

def find01():
    for i in list_skill:
        if i.atk_ratio > 6:
            yield i
            
for item in find01():
    print(item)

for item in (i for i in list_skill if i.atk_ratio > 6):
    print(item.name)    





```

